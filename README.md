# FullStackNotes
Chapter 1
1) (Project Object Method) pom.xml file holds basic information of the project and dependencies
2) Springboot Initializr can be used to set up a project with dependencies, version types, project type, and language preferance
3) Loggers can be used to capture errors when running a program
4) 7 logging levels: TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF
5) Logging levels are set in the application.properties file

Chapter 2
1) Dependency Injection (DI) is used for creating objects that depend on other objects
2) DIs allow classes to interact while maintaining independance
3) Three DI Class Types: service(a class that can be used, is a dependency), client(is a class that uses dependencies), injector(passes dependencies to client)

Chapter 3
1) JPA annotation @Entity is used to make an entity class
2) JPA creates a database table by the class name
3) @Table annotation in the entity class can rename the table
4) Entity class must have a primary key attribute defined by @Id annotation
5) @GeneratedValue annotation creates a unique value for primary key
6) Annotating multiple attributes with @Id creates a composite primary key
7) Entity tables columns are named after the class attributes
8) @Column annotation can be used to define length and if the column is nullable
9) CrudRepository used for basic CRUD functions (Create, Read, Update, Delete)
10) CrudRepository is extended in an entity's relates interface
11) CrudRepository requires a class and id type <ClassName, IdType>
12) @Autowired annotation is used to enable dependency injection
13) @Query annotation is used to create an SQL statement
14) Query staements should be written in the crud repository
15) @OneToMany annotation creates a relationship with one object to many of that object type
16) @ManyToOne annotation is sister to @OneToMany allowing multiple of an object type to belong to a single object
17) FetchType is used for pojo associations
18) toMany relation defaults to FetchType.LAZY
19) FetchType.LAZY used to only fetch the many when needed
20) FetchType.EAGER fetches all associated objects
21) Cascade attribute of @oneToMany defines the effects of updates and deletes on associated entities
22) @ManyToMany relationship creates a relationship of many objects to many objects

Chapter 4
1) Representational State Transfer (REST) is an architectural style for creating a web service
2) 6 Constraints of rest
  -Stateless: server holds no information about the client state
  -Client: client and server act independently, server only sends information upon a client request
  -Cacheable: stored responses for any repetition in client requests
  -Uniform Interface: requests from different clients look the same
  -Layered System: allows the use of layered system architecture
  -Code on Demand: optional constraint
3) Uniform Interface Elements
  -Idetification of resources: maintain unique identifiers for resources
  -Resource manipulation through representation: the format of a response, usually JSON or XML
  -Self-descriptive messages: clear messages for the servers understanding
  -Hypermedia as the Engine of Application State(HATEOAS): responses can contain links to other areas of service
4) HTTP requests are handled in the controller classes
5) Controller is established with the @RestController annotation
6) Methods in the controller class contain respective annotations and endpoints for their functions
7) Spring Data REST can be used create RESTful web services for the entities of the public repositories from the application
8) localhost:8080/api endpoint can resource endpoints of the project
9) The information is returned as a JSON in Hypertext Application Language (HAL) format

Chapter 5
1) Spring Security provides security services for Java-based web applications
2) Spring Security enables: 
  -AuthenticationManager bean with an in-memory single user
  -Ignored paths for common static resource locations, HTTP basic security for all other endpoints
  -Security events published to Spring's ApplicationEventPublisher interface
  -Common low level features are on by default
  -Default autogenerated login page
3) Configuring Spring Security behaviour requires a class that extends WebSecurityConfigAdapter
4) @Configure and @EnableWebSecurity annotations switch off default web security config in the class
5) When creating a User, a class that implements the UserDetailsService interface provides authentication and authorization from Spring Security
6) JSON Web Token (JWT) is a compact security implimentation that can be sent in a header request
7) JWT 3 components xxxxx.yyyyy.zzzzz.
  -xxxxx.: the header defining the token type and hashing algorithm
  -yyyyy.: the payload contains user information incase of authentication
  -zzzzz.: a signature to verify that a token has been changed
8) A JWT Service class requires several defined elements: EXPIRATIONTIME(defined in milliseconds), PREFIX(defines the token's prefix)
9) A LoginController layer will require an injected AuthenticationManager
10) Spring Security's AuthenticationEntryPoint interface can be used to handle exceptions for Login credentials
11) Cross-Origin Resource Sharing (CORS) filtering is needed for frontend, as it identifies requests that are cross-origin and adds proper headers

Chapter 15
1) Backend can be deployed with an executible Java ARchive(JAR) file
2) Maven projects require an additional plugin in the pom.xml to utilize
3) Frontend deployment with VS code uses a constants.js file withe the SERVER_URL constant matching the URL of a deployed backend's URL
